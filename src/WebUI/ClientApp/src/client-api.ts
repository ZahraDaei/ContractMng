//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.17.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IContractBudgetClient {

    get(): Promise<ContractBudgetVm>;

    create(command: CreateContractBudgetCommand): Promise<number>;

    update(id: number, command: UpdateContractBudgetCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractBudgetClient implements IContractBudgetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractBudgetVm> {
        let url_ = this.baseUrl + "/ContractBudget";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractBudgetVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractBudgetVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractBudgetVm>(null as any);
    }

    create(command: CreateContractBudgetCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractBudget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractBudgetCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractBudget/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractBudget/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractClient {

    get(): Promise<ContractVm>;

    create(command: CreateContractCommand): Promise<number>;

    update(id: number, command: UpdateContractCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractClient implements IContractClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractVm> {
        let url_ = this.baseUrl + "/Contract";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractVm>(null as any);
    }

    create(command: CreateContractCommand): Promise<number> {
        let url_ = this.baseUrl + "/Contract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractDocumentClient {

    get(): Promise<ContractDocumentVm>;

    create(command: CreateContractDocumentCommand): Promise<number>;

    update(id: number, command: UpdateContractDocumentCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractDocumentClient implements IContractDocumentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractDocumentVm> {
        let url_ = this.baseUrl + "/ContractDocument";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractDocumentVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractDocumentVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractDocumentVm>(null as any);
    }

    create(command: CreateContractDocumentCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractDocumentCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractDocument/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractDocument/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractLastStatusClient {

    get(): Promise<ContractLastStatusVm>;

    create(command: CreateContractLastStatusCommand): Promise<number>;

    update(id: number, command: UpdateContractLastStatusCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractLastStatusClient implements IContractLastStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractLastStatusVm> {
        let url_ = this.baseUrl + "/ContractLastStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractLastStatusVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLastStatusVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractLastStatusVm>(null as any);
    }

    create(command: CreateContractLastStatusCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractLastStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractLastStatusCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractLastStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractLastStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractLetterClient {

    get(): Promise<ContractLetterVm>;

    create(command: CreateContractLetterCommand): Promise<number>;

    update(id: number, command: UpdateContractLetterCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractLetterClient implements IContractLetterClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractLetterVm> {
        let url_ = this.baseUrl + "/ContractLetter";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractLetterVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractLetterVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractLetterVm>(null as any);
    }

    create(command: CreateContractLetterCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractLetter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractLetterCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractLetter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractLetter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractPartyClient {

    get(): Promise<ContractPartyVm>;

    create(command: CreateContractPartyCommand): Promise<number>;

    update(id: number, command: UpdateContractPartyCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractPartyClient implements IContractPartyClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractPartyVm> {
        let url_ = this.baseUrl + "/ContractParty";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractPartyVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractPartyVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractPartyVm>(null as any);
    }

    create(command: CreateContractPartyCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractParty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractPartyCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractParty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractParty/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractPaymentMethodClient {

    get(): Promise<ContractPaymentMethodVm>;

    create(command: CreateContractPaymentMethodCommand): Promise<number>;

    update(id: number, command: UpdateContractPaymentMethodCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractPaymentMethodClient implements IContractPaymentMethodClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractPaymentMethodVm> {
        let url_ = this.baseUrl + "/ContractPaymentMethod";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractPaymentMethodVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractPaymentMethodVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractPaymentMethodVm>(null as any);
    }

    create(command: CreateContractPaymentMethodCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractPaymentMethod";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractPaymentMethodCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractPaymentMethod/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractPaymentMethod/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IContractTypeClient {

    get(): Promise<ContractTypeVm>;

    create(command: CreateContractTypeCommand): Promise<number>;

    update(id: number, command: UpdateContractTypeCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class ContractTypeClient implements IContractTypeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<ContractTypeVm> {
        let url_ = this.baseUrl + "/ContractType";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractTypeVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractTypeVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractTypeVm>(null as any);
    }

    create(command: CreateContractTypeCommand): Promise<number> {
        let url_ = this.baseUrl + "/ContractType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateContractTypeCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/ContractType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ILastStatusClient {

    get(): Promise<LastStatusVm>;

    create(command: CreateLastStatusCommand): Promise<number>;

    update(id: number, command: UpdateLastStatusCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class LastStatusClient implements ILastStatusClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<LastStatusVm> {
        let url_ = this.baseUrl + "/LastStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LastStatusVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LastStatusVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LastStatusVm>(null as any);
    }

    create(command: CreateLastStatusCommand): Promise<number> {
        let url_ = this.baseUrl + "/LastStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateLastStatusCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/LastStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/LastStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface ILetterClient {

    get(): Promise<LetterVm>;

    create(command: CreateLetterCommand): Promise<number>;

    update(id: number, command: UpdateLetterCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class LetterClient implements ILetterClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<LetterVm> {
        let url_ = this.baseUrl + "/Letter";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LetterVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LetterVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LetterVm>(null as any);
    }

    create(command: CreateLetterCommand): Promise<number> {
        let url_ = this.baseUrl + "/Letter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateLetterCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Letter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/Letter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface IReportClient {

    getReportByParties(): Promise<ReportByPartyVm>;

    getReportByPayments(): Promise<ReportByPaymentVm>;

    getReportByStatuses(): Promise<ReportByStatusVm>;
}

export class ReportClient implements IReportClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getReportByParties(): Promise<ReportByPartyVm> {
        let url_ = this.baseUrl + "/Report/ReportByParties";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReportByParties(_response);
        });
    }

    protected processGetReportByParties(response: Response): Promise<ReportByPartyVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportByPartyVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportByPartyVm>(null as any);
    }

    getReportByPayments(): Promise<ReportByPaymentVm> {
        let url_ = this.baseUrl + "/Report/ReportByPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReportByPayments(_response);
        });
    }

    protected processGetReportByPayments(response: Response): Promise<ReportByPaymentVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportByPaymentVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportByPaymentVm>(null as any);
    }

    getReportByStatuses(): Promise<ReportByStatusVm> {
        let url_ = this.baseUrl + "/Report/ReportByStatuses";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetReportByStatuses(_response);
        });
    }

    protected processGetReportByStatuses(response: Response): Promise<ReportByStatusVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReportByStatusVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ReportByStatusVm>(null as any);
    }
}

export interface ITechnicalAttachmentClient {

    get(): Promise<TechnicalAttachmentVm>;

    create(name: string | null | undefined, number: string | null | undefined, file: FileParameter | null | undefined, contractNumber: string | null | undefined): Promise<number>;

    update(id: number, command: UpdateTechnicalAttachmentCommand): Promise<FileResponse>;

    delete(id: number): Promise<FileResponse>;
}

export class TechnicalAttachmentClient implements ITechnicalAttachmentClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<TechnicalAttachmentVm> {
        let url_ = this.baseUrl + "/TechnicalAttachment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<TechnicalAttachmentVm> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TechnicalAttachmentVm.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TechnicalAttachmentVm>(null as any);
    }

    create(name: string | null | undefined, number: string | null | undefined, file: FileParameter | null | undefined, contractNumber: string | null | undefined): Promise<number> {
        let url_ = this.baseUrl + "/TechnicalAttachment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (number !== null && number !== undefined)
            content_.append("Number", number.toString());
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");
        if (contractNumber !== null && contractNumber !== undefined)
            content_.append("ContractNumber", contractNumber.toString());

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    update(id: number, command: UpdateTechnicalAttachmentCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/TechnicalAttachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/TechnicalAttachment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export class ContractBudgetVm implements IContractBudgetVm {
    contractBudgetDtos?: ContractBudgetDto[];

    constructor(data?: IContractBudgetVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractBudgetDtos"])) {
                this.contractBudgetDtos = [] as any;
                for (let item of _data["contractBudgetDtos"])
                    this.contractBudgetDtos!.push(ContractBudgetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractBudgetVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractBudgetVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractBudgetDtos)) {
            data["contractBudgetDtos"] = [];
            for (let item of this.contractBudgetDtos)
                data["contractBudgetDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractBudgetVm {
    contractBudgetDtos?: ContractBudgetDto[];
}

export class ContractBudgetDto implements IContractBudgetDto {
    id?: number;
    placeOfBudget?: string;
    schemaNumber?: string;

    constructor(data?: IContractBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.placeOfBudget = _data["placeOfBudget"];
            this.schemaNumber = _data["schemaNumber"];
        }
    }

    static fromJS(data: any): ContractBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["placeOfBudget"] = this.placeOfBudget;
        data["schemaNumber"] = this.schemaNumber;
        return data;
    }
}

export interface IContractBudgetDto {
    id?: number;
    placeOfBudget?: string;
    schemaNumber?: string;
}

export class CreateContractBudgetCommand implements ICreateContractBudgetCommand {
    placeOfBudget?: string;
    schemaNumber?: string;

    constructor(data?: ICreateContractBudgetCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.placeOfBudget = _data["placeOfBudget"];
            this.schemaNumber = _data["schemaNumber"];
        }
    }

    static fromJS(data: any): CreateContractBudgetCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractBudgetCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["placeOfBudget"] = this.placeOfBudget;
        data["schemaNumber"] = this.schemaNumber;
        return data;
    }
}

export interface ICreateContractBudgetCommand {
    placeOfBudget?: string;
    schemaNumber?: string;
}

export class UpdateContractBudgetCommand implements IUpdateContractBudgetCommand {
    id?: number;
    placeOfBudget?: string;
    schemaNumber?: string;

    constructor(data?: IUpdateContractBudgetCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.placeOfBudget = _data["placeOfBudget"];
            this.schemaNumber = _data["schemaNumber"];
        }
    }

    static fromJS(data: any): UpdateContractBudgetCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractBudgetCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["placeOfBudget"] = this.placeOfBudget;
        data["schemaNumber"] = this.schemaNumber;
        return data;
    }
}

export interface IUpdateContractBudgetCommand {
    id?: number;
    placeOfBudget?: string;
    schemaNumber?: string;
}

export class ContractVm implements IContractVm {
    contractDtos?: ContractDto[];

    constructor(data?: IContractVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractDtos"])) {
                this.contractDtos = [] as any;
                for (let item of _data["contractDtos"])
                    this.contractDtos!.push(ContractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractDtos)) {
            data["contractDtos"] = [];
            for (let item of this.contractDtos)
                data["contractDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractVm {
    contractDtos?: ContractDto[];
}

export class ContractDto implements IContractDto {
    id?: number;
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;
    deleted?: boolean;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.subject = _data["subject"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.party = _data["party"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.finalAmount = _data["finalAmount"];
            this.budgetPlace = _data["budgetPlace"];
            this.deleted = _data["deleted"];
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["subject"] = this.subject;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["party"] = this.party;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["finalAmount"] = this.finalAmount;
        data["budgetPlace"] = this.budgetPlace;
        data["deleted"] = this.deleted;
        return data;
    }
}

export interface IContractDto {
    id?: number;
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;
    deleted?: boolean;
}

export class CreateContractCommand implements ICreateContractCommand {
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;

    constructor(data?: ICreateContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.subject = _data["subject"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.party = _data["party"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.finalAmount = _data["finalAmount"];
            this.budgetPlace = _data["budgetPlace"];
        }
    }

    static fromJS(data: any): CreateContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["subject"] = this.subject;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["party"] = this.party;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["finalAmount"] = this.finalAmount;
        data["budgetPlace"] = this.budgetPlace;
        return data;
    }
}

export interface ICreateContractCommand {
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;
}

export class UpdateContractCommand implements IUpdateContractCommand {
    id?: number;
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;

    constructor(data?: IUpdateContractCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.number = _data["number"];
            this.subject = _data["subject"];
            this.type = _data["type"];
            this.amount = _data["amount"];
            this.party = _data["party"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.finalAmount = _data["finalAmount"];
            this.budgetPlace = _data["budgetPlace"];
        }
    }

    static fromJS(data: any): UpdateContractCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["subject"] = this.subject;
        data["type"] = this.type;
        data["amount"] = this.amount;
        data["party"] = this.party;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["finalAmount"] = this.finalAmount;
        data["budgetPlace"] = this.budgetPlace;
        return data;
    }
}

export interface IUpdateContractCommand {
    id?: number;
    number?: string;
    subject?: string;
    type?: string;
    amount?: number;
    party?: string;
    startDate?: string;
    endDate?: string;
    finalAmount?: number;
    budgetPlace?: string;
}

export class ContractDocumentVm implements IContractDocumentVm {
    contractDocumentDtos?: ContractDocumentDto[];

    constructor(data?: IContractDocumentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractDocumentDtos"])) {
                this.contractDocumentDtos = [] as any;
                for (let item of _data["contractDocumentDtos"])
                    this.contractDocumentDtos!.push(ContractDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractDocumentVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDocumentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractDocumentDtos)) {
            data["contractDocumentDtos"] = [];
            for (let item of this.contractDocumentDtos)
                data["contractDocumentDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractDocumentVm {
    contractDocumentDtos?: ContractDocumentDto[];
}

export class ContractDocumentDto implements IContractDocumentDto {
    id?: number;
    document?: string;

    constructor(data?: IContractDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.document = _data["document"];
        }
    }

    static fromJS(data: any): ContractDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["document"] = this.document;
        return data;
    }
}

export interface IContractDocumentDto {
    id?: number;
    document?: string;
}

export class CreateContractDocumentCommand implements ICreateContractDocumentCommand {
    document?: string;

    constructor(data?: ICreateContractDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.document = _data["document"];
        }
    }

    static fromJS(data: any): CreateContractDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["document"] = this.document;
        return data;
    }
}

export interface ICreateContractDocumentCommand {
    document?: string;
}

export class UpdateContractDocumentCommand implements IUpdateContractDocumentCommand {
    id?: number;
    document?: string;

    constructor(data?: IUpdateContractDocumentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.document = _data["document"];
        }
    }

    static fromJS(data: any): UpdateContractDocumentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractDocumentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["document"] = this.document;
        return data;
    }
}

export interface IUpdateContractDocumentCommand {
    id?: number;
    document?: string;
}

export class ContractLastStatusVm implements IContractLastStatusVm {
    contractLastStatusDtos?: ContractLastStatusDto[];

    constructor(data?: IContractLastStatusVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractLastStatusDtos"])) {
                this.contractLastStatusDtos = [] as any;
                for (let item of _data["contractLastStatusDtos"])
                    this.contractLastStatusDtos!.push(ContractLastStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractLastStatusVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLastStatusVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractLastStatusDtos)) {
            data["contractLastStatusDtos"] = [];
            for (let item of this.contractLastStatusDtos)
                data["contractLastStatusDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractLastStatusVm {
    contractLastStatusDtos?: ContractLastStatusDto[];
}

export class ContractLastStatusDto implements IContractLastStatusDto {
    id?: number;
    status?: string;

    constructor(data?: IContractLastStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ContractLastStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLastStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IContractLastStatusDto {
    id?: number;
    status?: string;
}

export class CreateContractLastStatusCommand implements ICreateContractLastStatusCommand {
    status?: string;

    constructor(data?: ICreateContractLastStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateContractLastStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractLastStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateContractLastStatusCommand {
    status?: string;
}

export class UpdateContractLastStatusCommand implements IUpdateContractLastStatusCommand {
    id?: number;
    status?: string;

    constructor(data?: IUpdateContractLastStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateContractLastStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractLastStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateContractLastStatusCommand {
    id?: number;
    status?: string;
}

export class ContractLetterVm implements IContractLetterVm {
    contractLetterDtos?: ContractLetterDto[];

    constructor(data?: IContractLetterVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractLetterDtos"])) {
                this.contractLetterDtos = [] as any;
                for (let item of _data["contractLetterDtos"])
                    this.contractLetterDtos!.push(ContractLetterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractLetterVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLetterVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractLetterDtos)) {
            data["contractLetterDtos"] = [];
            for (let item of this.contractLetterDtos)
                data["contractLetterDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractLetterVm {
    contractLetterDtos?: ContractLetterDto[];
}

export class ContractLetterDto implements IContractLetterDto {
    id?: number;
    letterType?: string;

    constructor(data?: IContractLetterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.letterType = _data["letterType"];
        }
    }

    static fromJS(data: any): ContractLetterDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractLetterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["letterType"] = this.letterType;
        return data;
    }
}

export interface IContractLetterDto {
    id?: number;
    letterType?: string;
}

export class CreateContractLetterCommand implements ICreateContractLetterCommand {
    letterType?: string;

    constructor(data?: ICreateContractLetterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.letterType = _data["letterType"];
        }
    }

    static fromJS(data: any): CreateContractLetterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractLetterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["letterType"] = this.letterType;
        return data;
    }
}

export interface ICreateContractLetterCommand {
    letterType?: string;
}

export class UpdateContractLetterCommand implements IUpdateContractLetterCommand {
    id?: number;
    letterType?: string;

    constructor(data?: IUpdateContractLetterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.letterType = _data["letterType"];
        }
    }

    static fromJS(data: any): UpdateContractLetterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractLetterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["letterType"] = this.letterType;
        return data;
    }
}

export interface IUpdateContractLetterCommand {
    id?: number;
    letterType?: string;
}

export class ContractPartyVm implements IContractPartyVm {
    contractPartyDtos?: ContractPartyDto[];

    constructor(data?: IContractPartyVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractPartyDtos"])) {
                this.contractPartyDtos = [] as any;
                for (let item of _data["contractPartyDtos"])
                    this.contractPartyDtos!.push(ContractPartyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractPartyVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractPartyVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractPartyDtos)) {
            data["contractPartyDtos"] = [];
            for (let item of this.contractPartyDtos)
                data["contractPartyDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractPartyVm {
    contractPartyDtos?: ContractPartyDto[];
}

export class ContractPartyDto implements IContractPartyDto {
    id?: number;
    partyName?: string;
    contractTypeId?: number;

    constructor(data?: IContractPartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.partyName = _data["partyName"];
            this.contractTypeId = _data["contractTypeId"];
        }
    }

    static fromJS(data: any): ContractPartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractPartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["partyName"] = this.partyName;
        data["contractTypeId"] = this.contractTypeId;
        return data;
    }
}

export interface IContractPartyDto {
    id?: number;
    partyName?: string;
    contractTypeId?: number;
}

export class CreateContractPartyCommand implements ICreateContractPartyCommand {
    partyName?: string;
    contractTypeId?: number;

    constructor(data?: ICreateContractPartyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.partyName = _data["partyName"];
            this.contractTypeId = _data["contractTypeId"];
        }
    }

    static fromJS(data: any): CreateContractPartyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractPartyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["partyName"] = this.partyName;
        data["contractTypeId"] = this.contractTypeId;
        return data;
    }
}

export interface ICreateContractPartyCommand {
    partyName?: string;
    contractTypeId?: number;
}

export class UpdateContractPartyCommand implements IUpdateContractPartyCommand {
    id?: number;
    partyName?: string;
    contractTypeId?: number;

    constructor(data?: IUpdateContractPartyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.partyName = _data["partyName"];
            this.contractTypeId = _data["contractTypeId"];
        }
    }

    static fromJS(data: any): UpdateContractPartyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractPartyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["partyName"] = this.partyName;
        data["contractTypeId"] = this.contractTypeId;
        return data;
    }
}

export interface IUpdateContractPartyCommand {
    id?: number;
    partyName?: string;
    contractTypeId?: number;
}

export class ContractPaymentMethodVm implements IContractPaymentMethodVm {
    contractPaymentMethodDtos?: ContractPaymentMethodDto[];

    constructor(data?: IContractPaymentMethodVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractPaymentMethodDtos"])) {
                this.contractPaymentMethodDtos = [] as any;
                for (let item of _data["contractPaymentMethodDtos"])
                    this.contractPaymentMethodDtos!.push(ContractPaymentMethodDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractPaymentMethodVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractPaymentMethodVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractPaymentMethodDtos)) {
            data["contractPaymentMethodDtos"] = [];
            for (let item of this.contractPaymentMethodDtos)
                data["contractPaymentMethodDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractPaymentMethodVm {
    contractPaymentMethodDtos?: ContractPaymentMethodDto[];
}

export class ContractPaymentMethodDto implements IContractPaymentMethodDto {
    id?: number;
    method?: string;

    constructor(data?: IContractPaymentMethodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): ContractPaymentMethodDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractPaymentMethodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["method"] = this.method;
        return data;
    }
}

export interface IContractPaymentMethodDto {
    id?: number;
    method?: string;
}

export class CreateContractPaymentMethodCommand implements ICreateContractPaymentMethodCommand {
    method?: string;

    constructor(data?: ICreateContractPaymentMethodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): CreateContractPaymentMethodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractPaymentMethodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["method"] = this.method;
        return data;
    }
}

export interface ICreateContractPaymentMethodCommand {
    method?: string;
}

export class UpdateContractPaymentMethodCommand implements IUpdateContractPaymentMethodCommand {
    id?: number;
    method?: string;

    constructor(data?: IUpdateContractPaymentMethodCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): UpdateContractPaymentMethodCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractPaymentMethodCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["method"] = this.method;
        return data;
    }
}

export interface IUpdateContractPaymentMethodCommand {
    id?: number;
    method?: string;
}

export class ContractTypeVm implements IContractTypeVm {
    contractTypeDtos?: ContractTypeDto[];

    constructor(data?: IContractTypeVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contractTypeDtos"])) {
                this.contractTypeDtos = [] as any;
                for (let item of _data["contractTypeDtos"])
                    this.contractTypeDtos!.push(ContractTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContractTypeVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTypeVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contractTypeDtos)) {
            data["contractTypeDtos"] = [];
            for (let item of this.contractTypeDtos)
                data["contractTypeDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContractTypeVm {
    contractTypeDtos?: ContractTypeDto[];
}

export class ContractTypeDto implements IContractTypeDto {
    id?: number;
    type?: string;

    constructor(data?: IContractTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): ContractTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data;
    }
}

export interface IContractTypeDto {
    id?: number;
    type?: string;
}

export class CreateContractTypeCommand implements ICreateContractTypeCommand {
    type?: string;

    constructor(data?: ICreateContractTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): CreateContractTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        return data;
    }
}

export interface ICreateContractTypeCommand {
    type?: string;
}

export class UpdateContractTypeCommand implements IUpdateContractTypeCommand {
    id?: number;
    type?: string;

    constructor(data?: IUpdateContractTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): UpdateContractTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        return data;
    }
}

export interface IUpdateContractTypeCommand {
    id?: number;
    type?: string;
}

export class LastStatusVm implements ILastStatusVm {
    lastStatusDtos?: LastStatusDto[];

    constructor(data?: ILastStatusVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lastStatusDtos"])) {
                this.lastStatusDtos = [] as any;
                for (let item of _data["lastStatusDtos"])
                    this.lastStatusDtos!.push(LastStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LastStatusVm {
        data = typeof data === 'object' ? data : {};
        let result = new LastStatusVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lastStatusDtos)) {
            data["lastStatusDtos"] = [];
            for (let item of this.lastStatusDtos)
                data["lastStatusDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILastStatusVm {
    lastStatusDtos?: LastStatusDto[];
}

export class LastStatusDto implements ILastStatusDto {
    id?: number;
    date?: string;
    progress?: string;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;

    constructor(data?: ILastStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.progress = _data["progress"];
            this.amount = _data["amount"];
            this.amountNumber = _data["amountNumber"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): LastStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new LastStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["progress"] = this.progress;
        data["amount"] = this.amount;
        data["amountNumber"] = this.amountNumber;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface ILastStatusDto {
    id?: number;
    date?: string;
    progress?: string;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;
}

export class CreateLastStatusCommand implements ICreateLastStatusCommand {
    date?: string;
    contractLastStatusId?: number;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;

    constructor(data?: ICreateLastStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.contractLastStatusId = _data["contractLastStatusId"];
            this.amount = _data["amount"];
            this.amountNumber = _data["amountNumber"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): CreateLastStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLastStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["contractLastStatusId"] = this.contractLastStatusId;
        data["amount"] = this.amount;
        data["amountNumber"] = this.amountNumber;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface ICreateLastStatusCommand {
    date?: string;
    contractLastStatusId?: number;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;
}

export class UpdateLastStatusCommand implements IUpdateLastStatusCommand {
    id?: number;
    date?: string;
    contractLastStatusId?: number;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;

    constructor(data?: IUpdateLastStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.contractLastStatusId = _data["contractLastStatusId"];
            this.amount = _data["amount"];
            this.amountNumber = _data["amountNumber"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): UpdateLastStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLastStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["contractLastStatusId"] = this.contractLastStatusId;
        data["amount"] = this.amount;
        data["amountNumber"] = this.amountNumber;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface IUpdateLastStatusCommand {
    id?: number;
    date?: string;
    contractLastStatusId?: number;
    amount?: number;
    amountNumber?: number;
    contractNumber?: string;
}

export class LetterVm implements ILetterVm {
    letterDtos?: LetterDto[];

    constructor(data?: ILetterVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["letterDtos"])) {
                this.letterDtos = [] as any;
                for (let item of _data["letterDtos"])
                    this.letterDtos!.push(LetterDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LetterVm {
        data = typeof data === 'object' ? data : {};
        let result = new LetterVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.letterDtos)) {
            data["letterDtos"] = [];
            for (let item of this.letterDtos)
                data["letterDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILetterVm {
    letterDtos?: LetterDto[];
}

export class LetterDto implements ILetterDto {
    id?: number;
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;

    constructor(data?: ILetterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.subject = _data["subject"];
            this.number = _data["number"];
            this.letterDate = _data["letterDate"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): LetterDto {
        data = typeof data === 'object' ? data : {};
        let result = new LetterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["subject"] = this.subject;
        data["number"] = this.number;
        data["letterDate"] = this.letterDate;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface ILetterDto {
    id?: number;
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;
}

export class CreateLetterCommand implements ICreateLetterCommand {
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;

    constructor(data?: ICreateLetterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.subject = _data["subject"];
            this.number = _data["number"];
            this.letterDate = _data["letterDate"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): CreateLetterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLetterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["subject"] = this.subject;
        data["number"] = this.number;
        data["letterDate"] = this.letterDate;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface ICreateLetterCommand {
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;
}

export class UpdateLetterCommand implements IUpdateLetterCommand {
    id?: number;
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;

    constructor(data?: IUpdateLetterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.subject = _data["subject"];
            this.number = _data["number"];
            this.letterDate = _data["letterDate"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): UpdateLetterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLetterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["subject"] = this.subject;
        data["number"] = this.number;
        data["letterDate"] = this.letterDate;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface IUpdateLetterCommand {
    id?: number;
    type?: string;
    subject?: string;
    number?: string;
    letterDate?: string;
    contractNumber?: string;
}

export class ReportByPartyVm implements IReportByPartyVm {
    reportByPartyDtos?: ReportByPartyDto[];

    constructor(data?: IReportByPartyVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportByPartyDtos"])) {
                this.reportByPartyDtos = [] as any;
                for (let item of _data["reportByPartyDtos"])
                    this.reportByPartyDtos!.push(ReportByPartyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportByPartyVm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByPartyVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportByPartyDtos)) {
            data["reportByPartyDtos"] = [];
            for (let item of this.reportByPartyDtos)
                data["reportByPartyDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportByPartyVm {
    reportByPartyDtos?: ReportByPartyDto[];
}

export class ReportByPartyDto implements IReportByPartyDto {
    contractParty?: string;
    partyId?: number;
    contractType?: string;
    contracts?: ContractDto[];

    constructor(data?: IReportByPartyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractParty = _data["contractParty"];
            this.partyId = _data["partyId"];
            this.contractType = _data["contractType"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(ContractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportByPartyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByPartyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractParty"] = this.contractParty;
        data["partyId"] = this.partyId;
        data["contractType"] = this.contractType;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportByPartyDto {
    contractParty?: string;
    partyId?: number;
    contractType?: string;
    contracts?: ContractDto[];
}

export class ReportByPaymentVm implements IReportByPaymentVm {
    reportByPaymentDtos?: ReportByPaymentDto[];

    constructor(data?: IReportByPaymentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportByPaymentDtos"])) {
                this.reportByPaymentDtos = [] as any;
                for (let item of _data["reportByPaymentDtos"])
                    this.reportByPaymentDtos!.push(ReportByPaymentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportByPaymentVm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByPaymentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportByPaymentDtos)) {
            data["reportByPaymentDtos"] = [];
            for (let item of this.reportByPaymentDtos)
                data["reportByPaymentDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportByPaymentVm {
    reportByPaymentDtos?: ReportByPaymentDto[];
}

export class ReportByPaymentDto implements IReportByPaymentDto {
    number?: string;
    amount?: number;
    finalAmount?: number;
    subject?: string;
    type?: string;
    payments?: LastStatusDto[];
    contractId?: number;

    constructor(data?: IReportByPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.number = _data["number"];
            this.amount = _data["amount"];
            this.finalAmount = _data["finalAmount"];
            this.subject = _data["subject"];
            this.type = _data["type"];
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(LastStatusDto.fromJS(item));
            }
            this.contractId = _data["contractId"];
        }
    }

    static fromJS(data: any): ReportByPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["number"] = this.number;
        data["amount"] = this.amount;
        data["finalAmount"] = this.finalAmount;
        data["subject"] = this.subject;
        data["type"] = this.type;
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item.toJSON());
        }
        data["contractId"] = this.contractId;
        return data;
    }
}

export interface IReportByPaymentDto {
    number?: string;
    amount?: number;
    finalAmount?: number;
    subject?: string;
    type?: string;
    payments?: LastStatusDto[];
    contractId?: number;
}

export class ReportByStatusVm implements IReportByStatusVm {
    reportByStatusDtos?: ReportByStatusDto[];

    constructor(data?: IReportByStatusVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["reportByStatusDtos"])) {
                this.reportByStatusDtos = [] as any;
                for (let item of _data["reportByStatusDtos"])
                    this.reportByStatusDtos!.push(ReportByStatusDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportByStatusVm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByStatusVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.reportByStatusDtos)) {
            data["reportByStatusDtos"] = [];
            for (let item of this.reportByStatusDtos)
                data["reportByStatusDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportByStatusVm {
    reportByStatusDtos?: ReportByStatusDto[];
}

export class ReportByStatusDto implements IReportByStatusDto {
    contractLastStatusId?: number | undefined;
    status?: string | undefined;
    contracts?: ContractDto[] | undefined;

    constructor(data?: IReportByStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contractLastStatusId = _data["contractLastStatusId"];
            this.status = _data["status"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(ContractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportByStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contractLastStatusId"] = this.contractLastStatusId;
        data["status"] = this.status;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IReportByStatusDto {
    contractLastStatusId?: number | undefined;
    status?: string | undefined;
    contracts?: ContractDto[] | undefined;
}

export class TechnicalAttachmentVm implements ITechnicalAttachmentVm {
    technicalAttachmentDtos?: TechnicalAttachmentDto[];

    constructor(data?: ITechnicalAttachmentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["technicalAttachmentDtos"])) {
                this.technicalAttachmentDtos = [] as any;
                for (let item of _data["technicalAttachmentDtos"])
                    this.technicalAttachmentDtos!.push(TechnicalAttachmentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TechnicalAttachmentVm {
        data = typeof data === 'object' ? data : {};
        let result = new TechnicalAttachmentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.technicalAttachmentDtos)) {
            data["technicalAttachmentDtos"] = [];
            for (let item of this.technicalAttachmentDtos)
                data["technicalAttachmentDtos"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITechnicalAttachmentVm {
    technicalAttachmentDtos?: TechnicalAttachmentDto[];
}

export class TechnicalAttachmentDto implements ITechnicalAttachmentDto {
    id?: number;
    name?: string;
    number?: string;
    contractNumber?: string;

    constructor(data?: ITechnicalAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.number = _data["number"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): TechnicalAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new TechnicalAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["number"] = this.number;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface ITechnicalAttachmentDto {
    id?: number;
    name?: string;
    number?: string;
    contractNumber?: string;
}

export class UpdateTechnicalAttachmentCommand implements IUpdateTechnicalAttachmentCommand {
    id?: number;
    name?: string;
    number?: string;
    contractNumber?: string;

    constructor(data?: IUpdateTechnicalAttachmentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.number = _data["number"];
            this.contractNumber = _data["contractNumber"];
        }
    }

    static fromJS(data: any): UpdateTechnicalAttachmentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTechnicalAttachmentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["number"] = this.number;
        data["contractNumber"] = this.contractNumber;
        return data;
    }
}

export interface IUpdateTechnicalAttachmentCommand {
    id?: number;
    name?: string;
    number?: string;
    contractNumber?: string;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}